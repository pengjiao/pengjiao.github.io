[
{
	"uri": "https://pengjiao.github.io/r/",
	"title": "R",
	"tags": [],
	"description": "",
	"content": "Tips and Tricks for using R Programming In this section, I will share my notes on useful techniques for using R programming, along with corresponding examples.\n"
},
{
	"uri": "https://pengjiao.github.io/statistics/",
	"title": "Statistics",
	"tags": [],
	"description": "",
	"content": "Statistics "
},
{
	"uri": "https://pengjiao.github.io/datamining/",
	"title": "DataMinings",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pengjiao.github.io/",
	"title": "Myblog",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pengjiao.github.io/datamining/tcga_gtex_mrna_differential_analysis_1/",
	"title": "TCGA_GTEx_mRNA_differential_analysis_1",
	"tags": [],
	"description": "",
	"content": "\rThe FOLR1 gene and the MUC16 gene are significant genes involved in ovarian cancer, potentially serving as therapeutic targets.\nIn this blog post, I will investigate the expression levels of the MUC16 gene in ovarian cancer patients who exhibit low expression of the FOLR1 gene. The analysis will involve comparing gene exression data from ovarian cancer tissue with that from normal ovary tissue. However, given the lack of normal ovary control in The Cancer Genome Atlas (TCGA) data, I have incorporated normal ovary data from the Genotype-Tissue Expression (GTEx) database.\nThe RECOUNT2 and UCSC Xena projects, which provide gene expression data from TCGA and GTEx database, utilize consistent preprocessing pipelines to reduce batch effects and enhance the reliability of comparisons across diverse studies. Yet, these two projects may employ different preprocessing and normalization methods. To ensure the robustness of results, I have treated the two projects separately in this analysis.\nFor data acquisition, the R packages TCGAbiolinks (using the TCGAquery_recount2 function) and UCSCXenaTools were used to query and download TCGA-OV data and normal ovarian tissue data from GTEx, available in both the RECOUNT2 and UCSC Xena projects.\n01. Load library\rWe first need to load the necessary R packages that will be utilized throughout our study.\nlibrary(SummarizedExperiment)\rlibrary(TCGAbiolinks)\rlibrary(recount)\rlibrary(biomaRt)\rlibrary(org.Hs.eg.db)\rlibrary(dplyr)\rlibrary(tibble)\rlibrary(CCSBUtils)\rlibrary(ggpubr)\rlibrary(stringr)\r\r02. Data from RECOUNT2 project\rData prepare\rNext, we obtain and prepare our gene expression data from the RECOUNT2 project using R package TCGAbiolinks (TCGAquery_recount2).\nTCGAbiolinks is an R package that provides an integrated interface to access, analyze, and visualize TCGA data. With its ‘TCGAquery_recount2’ function, it allows us to access the preprocessed gene expression data available on the RECOUNT2 project with ease.\nIn the following steps, we’ll focus on tidying up this data, ensuring it’s ready for the subsequent analysis stages. We’ll select our genes of interest (FOLR1 and MUC16), and create subsets of the data corresponding to ovarian cancer samples and normal ovary tissue samples.\nAfter we obtain the data, we extract the gene expression data for the ovary tissue from both projects into SummarizedExperiment (SE) objects. These objects are then saved in an RData file for future reference and reanalysis.\n## query from Recount2 platform: Ovary Carcinoma\rrecount.gtex \u0026lt;- TCGAquery_recount2(project=\u0026quot;GTEX\u0026quot;, tissue=\u0026quot;ovary\u0026quot;)\rrecount.tcga \u0026lt;- TCGAquery_recount2(project=\u0026quot;TCGA\u0026quot;, tissue=\u0026quot;ovary\u0026quot;)\r## save data for reanalysis\r# save(recount.gtex, recount.tcga, file = \u0026quot;recount_gtex_tcga_ovary.RData\u0026quot;)\r#load(\u0026quot;recount_gtex_tcga_ovary.RData\u0026quot;)\r## to get the SE object\rSE.recount.gtex \u0026lt;- recount.gtex$GTEX_ovary\rSE.recount.tcga \u0026lt;- recount.tcga$TCGA_ovary\rThe Recount2 project uses Rail-RNA as its primary computational pipeline to process and align RNA sequencing (RNA-seq) data. Rail-RNA is an alignment and transcriptome reconstruction tool. There is difference between coverage counts from Recount2 project using Rail-RNA and typical read count matrices. Rail-RNA employs a “binning” procedure to the aligned reads, resulting in what are sometimes called “read coverage” or “coverage counts”. These coverage counts are the number of reads that overlap with each base pair of a gene, rather than just counting each read once as is done in traditional “read counts”. However, most methods were developed for read typical count matrices. Therefore, the Recount2 data must be scaled in order to compare samples within and across studies. Scaling ensures that differences in sequencing depth across samples do not distort the counts, making them directly comparable. In the context of your analysis, scaling the Recount2 data ensures that the gene expression levels you observe are reflective of true biological differences, rather than technical differences from sequencing.\nThere are two methods to scale the count data: either auc or mapped_reads. If set to auc it will scale the counts by the total coverage of the sample. That is, the area under the curve (AUC) of the coverage. If set to mapped_reads it will scale the counts by the number of mapped reads, whether the library was paired-end or not, and the desired read length (L).\n\\[\r\\sum_{i} \\frac{coverage_i}{AUC} * target = \\text{{scaled read counts}} \\tag{1}\r\\]\n\\[\r\\sum_{i} \\frac{coverage_i}{\\text{{Read Length}} * target}{mapped} = \\text{{scaled read counts}} \\tag{2}\r\\]\n## preparing/scaling Recount2 data because it was sequenced using Rail-RNA\reset.gtex \u0026lt;- assays(scale_counts(recount.gtex$GTEX_ovary, round = TRUE))$counts\reset.tcga \u0026lt;- assays(scale_counts(recount.tcga$TCGA_ovary, round = TRUE))$counts\r## Check that the number of reads is less than or equal to 40 million\rrse_scaled \u0026lt;- scale_counts(recount.gtex$GTEX_ovary, round = TRUE)\rsummary(colSums(assays(rse_scaled)$counts)) / 1e6\r## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 31.33 34.77 35.37 35.52 36.42 38.67\rThe next step is to segregate the TCGA data into primary tumors and normal samples. Note that TCGA does not typically include normal tissue samples. We then merge the GTEx and TCGA cancer data, joining them by gene names. This creates a new dataframe where each row represents a gene and the columns contain expression data from the two different sources. Duplicates, which might have same gene ID are removed. Lastly, we normalize and filter the data using TCGAanalyze functions from the TCGAbiolinks package. This includes GC content normalization, which adjusts for the varying guanine and cytosine content across different genes. Then, we apply a quantile filter, removing genes that have expression values in the lowest 25% quantile, as they may represent noise.\nThis completes the data preparation process. With this, our gene expression data from RECOUNT2 is now ready for further analysis.\n## replacing UUIDs with TCGA barcodes:\rcolnames(eset.tcga) \u0026lt;- colData(recount.tcga$TCGA_ovary)$gdc_cases.samples.portions.analytes.aliquots.submitter_id\r## segregate between primary tumors and normal samples\reset.tcga.cancer \u0026lt;- eset.tcga[,which(colData(recount.tcga$TCGA_ovary)$gdc_cases.samples.sample_type==\u0026quot;Primary Tumor\u0026quot;)]\reset.tcga.normal \u0026lt;- eset.tcga[,which(colData(recount.tcga$TCGA_ovary)$gdc_cases.samples.sample_type==\u0026quot;Solid Tissue Normal\u0026quot;)] # there is no tissue normal\r## merging data by row names\rdataPrep.ov \u0026lt;- merge(as.data.frame(eset.gtex), as.data.frame(eset.tcga.cancer), by=0, all=TRUE)\r## rename gene id and remove duplicated rows with same gene id\rdataPrep.ov \u0026lt;- column_to_rownames(dataPrep.ov, var = \u0026quot;Row.names\u0026quot;)\rnewgene \u0026lt;- str_split(rownames(dataPrep.ov), \u0026quot;\\\\.\u0026quot;, simplify = T)[,1]\rdataPrep.fil \u0026lt;- dataPrep.ov[which(!duplicated(newgene)),]\rrownames(dataPrep.fil) \u0026lt;- newgene[which(!duplicated(newgene))]\r## normalization and filtering data\rdataNorm.ov \u0026lt;- TCGAanalyze_Normalization(tabDF = dataPrep.fil,\rgeneInfo = geneInfoHT,\rmethod = \u0026quot;gcContent\u0026quot;)\rdataFilt.ov \u0026lt;- TCGAanalyze_Filtering(tabDF = dataNorm.ov,\rmethod = \u0026quot;quantile\u0026quot;, qnt.cut = 0.25)\r\rDifferential analysis\rThen, we perform differential expression analysis between normal and tumor samples using the TCGAanalyze_DEA function from the TCGAbiolinks package. This analysis is performed on a set of 108 normal and 430 tumor samples across 42755 mRNA or genes.\nThe ‘method’ argument is set to ‘glmLRT’, which specifies the use of the likelihood ratio test for model fitting in the limma package.\nAfter the differential expression analysis, the Ensembl gene IDs in the result are converted to HGNC symbols using the BioMart package. This makes the results more interpretable as HGNC symbols are more commonly used in the literature. The ‘getBM’ function from the BioMart package is used for this conversion. The resulting table contains both the Ensembl gene IDs and corresponding HGNC symbols for each differentially expressed gene.\n## set \u0026quot;metadata\u0026quot; argument to true when dealing with TCGA data\r#in order to extract batch correction data\r#processing 108 normal and 430 tumor samples on 42755 mRNA or genes\rDEG.ov \u0026lt;- TCGAanalyze_DEA( mat1 = dataFilt.ov[,colnames(eset.gtex)],\rmat2 = dataFilt.ov[,colnames(eset.tcga.cancer)],\rmetadata =FALSE,\rpipeline=\u0026quot;limma\u0026quot;,\rvoom = TRUE,\rCond1type = \u0026quot;Normal\u0026quot;,\rCond2type = \u0026quot;Tumor\u0026quot;,\rfdr.cut = 0.01 ,\rlogFC.cut = 1,\rmethod = \u0026quot;glmLRT\u0026quot;)\r## converting ensenmbl gene ids to huugo gymbols using Biomart package\rmart \u0026lt;- useDataset(\u0026quot;hsapiens_gene_ensembl\u0026quot;, useMart(\u0026quot;ensembl\u0026quot;))\rG_list \u0026lt;- getBM(filters= \u0026quot;ensembl_gene_id\u0026quot;, attributes= c(\u0026quot;ensembl_gene_id\u0026quot;,\u0026quot;hgnc_symbol\u0026quot;), values=rownames(DEG.ov), mart= mart)\rDEG.ov \u0026lt;- rownames_to_column(DEG.ov, var = \u0026quot;ensembl_gene_id\u0026quot;)\rdeg.ov \u0026lt;- merge(DEG.ov, G_list, by = \u0026quot;ensembl_gene_id\u0026quot;)\r\rExamine the expression levels of the MUC16 gene in ovarian cancer patients who exhibit low expression of the FOLR1 gene\rWe define the low expression of the FOLR1 gene as expression level of FOLR1 gene was lower than median expression level. First we tranform counts into TPMs using getTPM function.\n\\[\rRPKM =\\frac{Number\\ of\\ Reads}{(\\frac{Gene\\ Length}{1000})*(\\frac{Total\\ reads}{10^6})}\r\\]\n\\[\rTPM = \\frac{{RPKM}}{{\\sum{RPKM}}} \\times 10^6\r\\]\n## transform counts into TPMs\rgtex.tpm \u0026lt;- getTPM(scale_counts(recount.gtex$GTEX_ovary, round = TRUE)) %\u0026gt;% data.frame()\rtcga.tpm \u0026lt;- getTPM(scale_counts(recount.tcga$TCGA_ovary, round = TRUE)) %\u0026gt;% data.frame()\r## replacing UUIDs with TCGA barcodes:\rcolnames(tcga.tpm) \u0026lt;- colData(recount.tcga$TCGA_ovary)$gdc_cases.samples.portions.analytes.aliquots.submitter_id\r## rename the gene id and remove duplicated rows with same gene id from TPM data\rtpmgenes \u0026lt;- str_split(rownames(tcga.tpm), \u0026quot;\\\\.\u0026quot;, simplify = T)[,1]\rtcga.tpm.df \u0026lt;- tcga.tpm[which(!duplicated(tpmgenes)),]\rrownames(tcga.tpm.df) \u0026lt;- tpmgenes[which(!duplicated(tpmgenes))]\rgtex.tpm.df \u0026lt;- gtex.tpm[which(!duplicated(tpmgenes)),]\rrownames(gtex.tpm.df) \u0026lt;- tpmgenes[which(!duplicated(tpmgenes))]\r## converting ensenmbl gene ids to huugo gymbols using Biomart package\rG_list.tpm \u0026lt;- getBM(filters= \u0026quot;ensembl_gene_id\u0026quot;, attributes= c(\u0026quot;ensembl_gene_id\u0026quot;,\u0026quot;hgnc_symbol\u0026quot;), values=rownames(tcga.tpm.df), mart= mart)\r## remove the rows without gene names\r### merging data by ensembl_gene_id\rtcga.tpm.df$ensembl_gene_id \u0026lt;- rownames(tcga.tpm.df)\rtcga.tpm.mer \u0026lt;- merge(G_list.tpm, tcga.tpm.df, by = \u0026quot;ensembl_gene_id\u0026quot;)\rtcga.tpm.sel \u0026lt;- tcga.tpm.mer[tcga.tpm.mer$hgnc_symbol != \u0026quot;\u0026quot;, -1]\rtcga.tpm.sel \u0026lt;- tcga.tpm.sel[which(!duplicated(tcga.tpm.sel$hgnc_symbol)),]\rrownames(tcga.tpm.sel) \u0026lt;- NULL\rtcga.tpm.fil \u0026lt;- column_to_rownames(tcga.tpm.sel, \u0026quot;hgnc_symbol\u0026quot;)\rgtex.tpm.df$ensembl_gene_id \u0026lt;- row.names.data.frame(gtex.tpm.df)\rgtex.tpm.mer \u0026lt;- merge(G_list.tpm, gtex.tpm.df, by = \u0026quot;ensembl_gene_id\u0026quot;)\rgtex.tpm.sel \u0026lt;- gtex.tpm.mer[gtex.tpm.mer$hgnc_symbol != \u0026quot;\u0026quot;,-1]\rgtex.tpm.sel \u0026lt;- gtex.tpm.sel[which(!duplicated(gtex.tpm.sel$hgnc_symbol)),]\rrownames(gtex.tpm.sel) \u0026lt;- NULL\rgtex.tpm.fil \u0026lt;- column_to_rownames(gtex.tpm.sel, \u0026quot;hgnc_symbol\u0026quot;)\rThere is no significant difference between low and high expressions of the FOLR1 gene. And MUC16 expression is significantly higher in patients with both low and high FOLR1 gene expression compared to normal ovary tissues.\n## calculate the mean tpm per gene\rtcga.tpm.mean \u0026lt;- apply(tcga.tpm.fil, 1, mean, na.rm = T)\rtcga.tpm.mean[names(tcga.tpm.mean) == \u0026quot;FOLR1\u0026quot;]\r## FOLR1 ## 419.3596\rtcga.tpm.mean[names(tcga.tpm.mean) == \u0026quot;MUC16\u0026quot;]\r## MUC16 ## 42.91637\r## extract patients with FOLR1 expression level lower than median value\rlower.sample \u0026lt;- colnames(tcga.tpm.fil)[which(tcga.tpm.fil[rownames(tcga.tpm.fil) == \u0026quot;FOLR1\u0026quot;,] \u0026lt; tcga.tpm.mean[names(tcga.tpm.mean) == \u0026quot;FOLR1\u0026quot;])] # 260\rupper.sample \u0026lt;- colnames(tcga.tpm.fil)[which(tcga.tpm.fil[rownames(tcga.tpm.fil) == \u0026quot;FOLR1\u0026quot;,] \u0026gt;= tcga.tpm.mean[names(tcga.tpm.mean) == \u0026quot;FOLR1\u0026quot;])] # 170\r## extract tpm data of folr1 and muc16\rlower.tcga.tpm \u0026lt;- tcga.tpm.fil[rownames(tcga.tpm.fil) %in% c(\u0026quot;FOLR1\u0026quot;, \u0026quot;MUC16\u0026quot;),colnames(tcga.tpm.fil) %in% lower.sample]\rupper.tcga.tpm \u0026lt;- tcga.tpm.fil[rownames(tcga.tpm.fil) %in% c(\u0026quot;FOLR1\u0026quot;, \u0026quot;MUC16\u0026quot;),colnames(tcga.tpm.fil) %in% upper.sample]\rlower.gtex.tpm \u0026lt;- gtex.tpm.fil[rownames(gtex.tpm.fil) %in% c(\u0026quot;FOLR1\u0026quot;, \u0026quot;MUC16\u0026quot;),]\r## data used for boxplot\rov.lower.df \u0026lt;- data.frame(t(lower.tcga.tpm))\rov.lower.df$group \u0026lt;- \u0026quot;Low_FOLR1\u0026quot;\rov.upper.df \u0026lt;- data.frame(t(upper.tcga.tpm))\rov.upper.df$group \u0026lt;- \u0026quot;High_FOLR1\u0026quot;\rnor.df \u0026lt;- data.frame(t(lower.gtex.tpm))\rnor.df$group \u0026lt;- \u0026quot;Normal\u0026quot;\rbox.df \u0026lt;- rbind(ov.lower.df, ov.upper.df, nor.df)\rbox.df$FOLR1 \u0026lt;- log2(box.df$FOLR1 + 1)\rbox.df$MUC16 \u0026lt;- log2(box.df$MUC16 + 1)\rbox.df$group \u0026lt;- factor(box.df$group, levels = c(\u0026quot;Normal\u0026quot;, \u0026quot;Low_FOLR1\u0026quot;, \u0026quot;High_FOLR1\u0026quot;))\rmy_comparisons \u0026lt;- list( c(\u0026quot;Normal\u0026quot;, \u0026quot;Low_FOLR1\u0026quot;), c(\u0026quot;Normal\u0026quot;, \u0026quot;High_FOLR1\u0026quot;), c(\u0026quot;Low_FOLR1\u0026quot;, \u0026quot;High_FOLR1\u0026quot;) )\rggboxplot(box.df, x = \u0026quot;group\u0026quot;, y = \u0026quot;MUC16\u0026quot;,\rcolor = \u0026quot;group\u0026quot;, palette = \u0026quot;lancet\u0026quot;,\radd = \u0026quot;jitter\u0026quot;) +\rstat_compare_means(comparisons = my_comparisons)\rggboxplot(box.df, x = \u0026quot;group\u0026quot;, y = \u0026quot;FOLR1\u0026quot;,\rcolor = \u0026quot;group\u0026quot;, palette = \u0026quot;lancet\u0026quot;,\radd = \u0026quot;jitter\u0026quot;) +\rstat_compare_means(comparisons = my_comparisons)\r\r\r"
},
{
	"uri": "https://pengjiao.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://pengjiao.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]